/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import React, {
	useContext,
	useEffect,
	useLayoutEffect,
	useRef,
	useState,
} from 'react';
import {
	useGLTF,
	useScroll,
	Scroll,
	Text,
	Html,
	Text3D,
	Center,
} from '@react-three/drei';
import Queen from '../Queen/Queen';
import Checkboard from '../Checkboard/Checkboard';
import Pawn from '../Pawn/Pawn';
import Rook from '../Rook/Rook';
import { useControls } from 'leva';
import { useFrame, useThree } from '@react-three/fiber';
import { animate, useMotionValue } from 'framer-motion';
import * as THREE from 'three';
import BannerPhrase from '../BannerPhrase/BannerPhrase';
import { motion } from 'framer-motion-3d';
import styles from './Chess.module.scss';
import { ThemeContext } from '../Context/ThemeContext';
import gsap from 'gsap';
import Cursor from '../Cursor/Cursor';
export default function Chess(props) {
	const scroll = useScroll();
	let scrollY = useMotionValue(15);
	let animateFov = useMotionValue(50);
	const intensityLight = useMotionValue(0);
	const [lastPosition, setLastPosition] = useState(0);
	// const [ scrollingDown, setScrollingDown ] = useState( false );
	const lightRef = useRef();
	const { title, scrollingDown, setScrollingDown } = useContext(ThemeContext);
	const workTitleRef = useRef(null);
	useFrame(state => {
		if (lastPosition > scroll.offset) {
			animate(scrollY, 15, { duration: 0.5 });
			animate(animateFov, 50, { duration: 0.5 });
			animate(intensityLight, 0, { duration: 0.5 });
			lightRef.current.intensity = intensityLight.get();
			state.camera.position.y = scrollY.get();
			state.camera.fov = animateFov.get();
			state.camera.lookAt(0, 0, 0);
			state.camera.updateProjectionMatrix();
			setScrollingDown(false);
		}
		if (lastPosition < scroll.offset) {
			animate(scrollY, 37, { duration: 0.5 });
			animate(animateFov, 15, { duration: 0.5 });
			animate(intensityLight, 5, { duration: 0.5 });
			lightRef.current.intensity = intensityLight.get();
			state.camera.position.y = scrollY.get();
			state.camera.fov = animateFov.get();
			state.camera.lookAt(0, 0, 0);
			state.camera.updateProjectionMatrix();
			setScrollingDown(true);
		}
		// lastPosition = scroll.offset;
		setLastPosition(scroll.offset);
	});

	const { whiteQueenPosition } = useControls('whiteQueen', {
		whiteQueenPosition: {
			value: { x: -0.44, y: 0.18, z: 5.18 },
			step: 0.01,
		},
	});

	const { whitePawnPosition } = useControls('whitePawn', {
		whitePawnPosition: {
			value: { x: -3.28, y: 0.42, z: 4.93 },
			step: 0.01,
		},
	});

	const { nodes, materials } = useGLTF('./checkboard.glb');

	const variants = {
		hidden: {
			opacity: 0,
		},
		visible: {
			opacity: 1,
			transition: {
				duration: 1,
			},
		},
	};

	const titleElement = document.querySelector(
		`.${styles.cursor}`,
	) as HTMLElement;

	useEffect(() => {
		// if (workTitleRef && workTitleRef.current) {
		window.addEventListener('mousemove', e => {
			workTitleRef.current.style.top = e.clientY + 'px';
			workTitleRef.current.style.left = e.clientX + 'px';
			// gsap.to(titleElement, {
			// 	x: 100,
			// 	duration: 2,
			// });
		});
		// }
	}, [title]);
	let displayTitleByCase = {
		work: <h2 className={styles.workTitle}> {title} </h2>,
		about: <h2 className={styles.aboutTitle}> {title} </h2>,
		contact: <h2 className={styles.contactTitle}> {title} </h2>,
	};

	return (
		<>
			<ambientLight
				ref={lightRef}
				intensity={0}
			/>
			<Scroll html>
				<BannerPhrase
					bannerPhrase={["LET'S", 'BUILD THE SITE', 'OF THE FUTURE']}
					scrollingDown={scrollingDown}
				/>
				{/* {scrollingDown && ( */}
				{/* <h2
					ref={workTitleRef}
					className={
						// title ? `${styles.title} ${styles.animateTitle}` : styles.cursor
						title ? `${styles.cursor} ${styles.animatedCursor}` : styles.cursor
						// styles.cursor
					}
				>
					{title}
				</h2> */}
				<Cursor
					ref={workTitleRef}
					title={title}
				/>
				{/* )} */}
			</Scroll>
			<group
				{...props}
				dispose={null}
			>
				<Queen
					positionX={whiteQueenPosition.x}
					positionY={whiteQueenPosition.y}
					positionZ={whiteQueenPosition.z}
				/>
				{/* <mesh
					castShadow
					receiveShadow
					geometry={nodes.Queen_1.geometry}
					material={nodes.Queen_1.material}
					position={[-0.44, 0.18, 5.18]}
				/> */}
				<Checkboard scrollingDown={scrollingDown} />
				{/* <group position={[-9.14, 0, 3.88]} rotation={[0, 1.56, 0]}>
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.Cube003.geometry}
          material={materials.Checker}
        />
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.Cube003_1.geometry}
          material={materials.Material}
        />
      </group> */}
				{/* <mesh
					castShadow
					receiveShadow
					geometry={nodes.Pawn.geometry}
					material={materials['pawn white']}
					position={[-3.28, 0.42, 4.93]}
					rotation={[Math.PI / 2, 0, 0]}
				/> */}
				<Pawn
					positionX={whitePawnPosition.x}
					positionY={whitePawnPosition.y}
					positionZ={whitePawnPosition.z}
				/>
				<Rook />
				{/* <mesh
					castShadow
					receiveShadow
					geometry={nodes.rook.geometry}
					material={nodes.rook.material}
					// position={[0.02, 0.25, -4.82]}
					position={nodes.rook.position}
					scale={0.64}
				/> */}
				<mesh
					castShadow
					receiveShadow
					geometry={nodes.knight_top.geometry}
					material={nodes.knight_top.material}
					position={[0.01, 1.27, -2.27]}
					rotation={[0, -0.03, 0]}
				/>
				<mesh
					castShadow
					receiveShadow
					geometry={nodes.Bishop001.geometry}
					material={nodes.Bishop001.material}
					// position={[0, 0.03, 0.12]}
				/>
				<mesh
					castShadow
					receiveShadow
					geometry={nodes.KIng001.geometry}
					material={nodes.KIng001.material}
					position={[-0.42, 0.03, 2.8]}
					// position={nodes.KIng001.position}
					rotation={[0, -1.23, 0]}
				/>
			</group>
			{/* <Text
        characters="abcdefghijklmnopqrstuvwxyz0123456789!"
        position={[0, 10, 0]}
      >
        hello world!
      </Text> */}
		</>
	);
}

useGLTF.preload('./checkboard.glb');
